/* autogenerated by Processing revision 1290 on 2023-04-26 */
import processing.core.*;
import processing.data.*;
import processing.event.*;
import processing.opengl.*;

import java.util.HashMap;
import java.util.ArrayList;
import java.io.File;
import java.io.BufferedReader;
import java.io.PrintWriter;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.IOException;

public class Game extends PApplet {

// color configs
static final int DARK_GREY = 0xFF292929;
static final int DARK_BLUE = 0xFF2F3948;
static final int YELLOW = 0xFFFFB347;
static final int ORANGE = 0xFFFF8C00;
static final int PURPLE = 0xFF2F245A;
static final int LIGHT_PURPLE = 0xFF8C71E9;
static final int RED = 0xFFB20000;
static final int PINK = 0xFFC15858;
static final int BLUE = 0xFF5588FF;

// states
final int STATE_MENU = 0;
final int STATE_GAME = 1;
final int STATE_GAMELOADING = 2;
final int STATE_GAMEOVER = 3;
final int STATE_GAMEPAUSE = 4;
int state = 0;  // initial state

// use a boolean array to register key presses
boolean[] keys = new boolean[128];
// special key presses
boolean shiftpressed, enterpressed;

float proportion = 1.0f;
int default_width = 1600;
int default_height = 900;

Player player = new Player(50, 50, 50);
Menu menu;

public void settings() {
  size(default_width, default_height);
}

public void setup() {
  background(DARK_GREY);
  frameRate(60);
  player.position.x = width / 2;
  player.position.y = height / 2;
  menu = new Menu(this);
}

public void draw(){
  background(DARK_GREY);
  switch (state) {
    case STATE_MENU:
    showMenu(); break;
    case STATE_GAME:
    showGame(); break;
    case STATE_GAMELOADING:
    showLoading(); break;
    case STATE_GAMEOVER:
    showGameover(); break;
    case STATE_GAMEPAUSE:
    showGamePause(); break;
   }
  drawMouse();

}

public void showMenu() {
  player.drawPlayer();
  menu.drawMenu();
}

public void showGame() {
  player.drawPlayer();
}

public void showLoading() {
  fill(ORANGE);
  textSize(50);
  text("Loading", width / 2, height / 2);
}

public void showGameover() {
  fill(ORANGE);
  textSize(50);
  text("Gameover", width / 2, height / 2);
}

public void showGamePause() {
  fill(ORANGE);
  textSize(50);
  text("Game Pause", width / 2, height / 2);
}

public void keyPressed() {
  if (key >= 0 && key < keys.length) {
    keys[key] = true;
  }
  if (keyCode == SHIFT) {
    shiftpressed = true;
  }
  if (keyCode == ENTER) {
    enterpressed = true;
  }
}

public void keyReleased() {
  if (key >= 0 && key < keys.length) {
    keys[key] = false;
  }
  if (keyCode == SHIFT) {
    shiftpressed = false;
  }
  if (keyCode == ENTER) {
    enterpressed = false;
  }
}

public void drawMouse() {
  noCursor(); // hide cursor
  stroke(YELLOW);
  strokeWeight(1);
  line(mouseX - proportion * 12, mouseY, mouseX + proportion * 12, mouseY);  // draw a cross
  line(mouseX, mouseY - proportion * 12, mouseX, mouseY + proportion * 12);
  noFill(); // Set fill color to transparent
  rectMode(CENTER);
  rect(mouseX, mouseY, 14, 14);
  fill(ORANGE); // Reset fill color to white for text

  textSize(15);
  textAlign(LEFT);
  text("Mouse location: (" + mouseX + ", " + mouseY + ")", mouseX + 15, mouseY + 30); // show mouse coord and fps 
  text("FPS: " + nf(frameRate, 0, 2), mouseX + 15, mouseY + 50);
  text("Screen resolution: " + width + " x " + height, mouseX + 15, mouseY + 70); // show screen resolution
  String pressedKeys = "Keys pressed: ";
  for (int i = 0; i < keys.length; i++) {

    if (keys[i] && i != 10 && i != 32) {
      pressedKeys += ' ';
      pressedKeys += PApplet.parseChar(i);
    }
  }
  if (shiftpressed) {
    pressedKeys += " SHIFT";
  }
  if (keys[32]) {
    pressedKeys += " SPACE";
  }
  if (keys[10]) {
    pressedKeys += " ENTER";
  }
  text(pressedKeys, mouseX + 15, mouseY + 90);
}
static class Collision {
    
    public static boolean pointCollideCircle(PVector pointPos, PVector circleCenter, float radius) {
        float distance = dist(circleCenter.x, circleCenter.y, pointPos.x, pointPos.y);
        if (distance <= radius) return true;
        return false;
    }
    
    public static boolean pointCollideRect(PVector pointPos, float rectX, float rectY, float rectW, float rectH) {
        // assuming rect is drawn at the corner
        if (pointPos.x >= rectX && pointPos.x <= rectX + rectW && pointPos.y >= rectY && pointPos.y <= rectY + rectH) {
            return true;
        } else return false;
    }
    
    public static boolean CircleCollideRect(float circleX, float circleY, float radius, float rectX, float rectY, float rectW, float rectH) {
        // assuming both are drawn at center
        float testX = circleX;
        float testY = circleY;
        
        // find the cloest edge
        if (circleX <= rectX - rectW / 2)         testX = rectX - rectW / 2;   // test left edge
        else if (circleX > rectX + rectW / 2)     testX = rectX + rectW / 2;   // right edge
        if (circleY <= rectY - rectH / 2)         testY = rectY - rectH / 2;   // top edge
        else if (circleY > rectY + rectH / 2)     testY = rectY + rectH / 2;   // bottom edge
        
        // get distance from closest edges
        float distX = circleX - testX;
        float distY = circleY - testY;
        float distance = sqrt((distX * distX) + (distY * distY));
        
        if (distance <= radius) return true;
        return false;
    }
    
    
    
    public static boolean circleCollideCircle(float circle1X, float circle1Y, float circle1Radius, float circle2X, float circle2Y, float circle2Radius) {
        float distance = dist(circle1X, circle1Y, circle2X, circle2Y);
        if (distance <= circle1Radius + circle2Radius) {
            return true;
        }
        return false;
    }
        
        public static boolean RectCollideRect(float rect1X, float rect1Y, float rect1W, float rect1H, float rect2X, float rect2Y, float rect2W, float rect2H) {
            if (rect1X + rect1W / 2 >= rect2X - rect2W / 2 && rect1X - rect1W / 2 <= rect2X + rect2W / 2 && rect1Y + rect1H / 2 >= rect2Y - rect2H / 2 && rect1Y - rect1H / 2 <= rect2Y + rect2H / 2) {
                return true;
            }
            return false;
        }
            
        }

class Menu {
    
    //Constants for menu appearance
    int menuX, menuY;
    int optionWidth = 300;
    int optionHeight = 60;
    int optionSpacing = 0;
    final MenuOption[] rootOptions;
    
    
    Menu(PApplet game) {
        this.menuX = game.width * 1 / 8;
        this.menuY = game.height * 1 / 10;
        
        int spaceCounter = 0;
        this.rootOptions = new MenuOption[] {
            new MenuOption("Start New Game", menuX, menuY + spaceCounter++ * (optionHeight + optionSpacing), optionWidth, optionHeight),
            new MenuOption("Load Game", menuX, menuY + spaceCounter++ * (optionHeight + optionSpacing), optionWidth, optionHeight),
            new MenuOption("Settings", menuX, menuY + spaceCounter++ * (optionHeight + optionSpacing), optionWidth, optionHeight),
            new MenuOption("Quit Game", menuX, menuY + spaceCounter++ * (optionHeight + optionSpacing), optionWidth, optionHeight)
        };

        spaceCounter = 0;
        rootOptions[2].subOptions = new MenuOption[] {
            new MenuOption("Resolution", menuX, rootOptions[2].menuOptionY + ++ spaceCounter * (optionHeight + optionSpacing), optionWidth, optionHeight),
            new MenuOption("Music Volumn", menuX, rootOptions[2].menuOptionY + ++spaceCounter * (optionHeight + optionSpacing), optionWidth, optionHeight),
        };

        
    }
    
    public void drawMenu() {
        
        // Draw menu options
        for (int i = 0; i < rootOptions.length; i++) {
            rootOptions[i].drawMenuOption();
        }

        if (rootOptions[2].selected) {
            rootOptions[0].ommited = true;
            rootOptions[1].ommited = true;
            rootOptions[3].ommited = true;
        } else {
            rootOptions[0].ommited = false;
            rootOptions[1].ommited = false;
            rootOptions[3].ommited = false;
        }
    }
}
class MenuOption {
    
    //Constants for menu appearance
    int menuOptionX, menuOptionY, optionWidth, optionHeight;
    float optionTextSize, selectedOptionTextSize, notSelectedOptionTextSize;
    String optionText;
    boolean selected, anyChildSelected, ommited;
    MenuOption[] subOptions;
    MenuOption parentOption;
    float optionColorOpa;
    int optionColor = LIGHT_PURPLE;
    
    MenuOption(String optionText, int menuOptionX, int menuOptionY, int optionWidth, int optionHeight) {
        this.menuOptionX = menuOptionX;
        this.menuOptionY = menuOptionY;
        this.optionWidth = optionWidth;
        this.optionHeight = optionHeight;
        this.optionTextSize = optionHeight * 1 / 2;
        this.notSelectedOptionTextSize = optionTextSize;
        this.selectedOptionTextSize = optionTextSize * 1.1f;
        this.optionText = optionText;
        
    }
    
    public void drawMenuOption() {

        if (ommited) {
            return;
        }
        updateOption();
        noStroke();
        
        rectMode(CENTER);
        if (selected) {
            optionColorOpa = lerp(optionColorOpa, 120, 0.1f);
            optionTextSize = lerp(optionTextSize, selectedOptionTextSize, 0.1f);
            fill(optionColor, optionColorOpa);
            rect(menuOptionX, menuOptionY, optionWidth, optionHeight, 10, 10, 10, 10);
            textAlign(CENTER, CENTER); 
            textSize(optionTextSize);
            fill(YELLOW);
            text(optionText, menuOptionX, menuOptionY);
            
            if (subOptions != null) {
                for (int i = 0; i < subOptions.length; i++) {
                    subOptions[i].drawMenuOption();
                }
            }
            
        } else{
            optionColorOpa = lerp(optionColorOpa, 0.0f, 0.1f);
            optionTextSize = lerp(optionTextSize, notSelectedOptionTextSize, 0.1f);
            fill(optionColor, optionColorOpa);
            rect(menuOptionX, menuOptionY, optionWidth, optionHeight, 10, 10, 10, 10);
            textAlign(CENTER, CENTER); 
            textSize(optionTextSize);
            fill(YELLOW);
            text(optionText, menuOptionX, menuOptionY);
        }
    }
    
    public void updateOption() {
        // Check if mouse is within bounds of the rectangle
        if (mouseX >= menuOptionX - optionWidth / 2 && mouseX <= menuOptionX + optionWidth / 2 && 
            mouseY >= menuOptionY - optionHeight / 2 && mouseY <= menuOptionY + optionHeight / 2) {
            selected = true;
        } else if (subOptions != null) {
            anyChildSelected = false;
            
            for (int i = 0; i < subOptions.length; i++) {
                if (subOptions[i].selected) {
                    anyChildSelected = true;
                }
                selected = anyChildSelected;
            }
        } else {
            selected = false;
        }
        
        
    }
}
class Player {
    boolean isAtLeftBorder, isAtRightBorder, isAtTopBorder, isAtBottomBorder; // to control movement
    float playerRadius, playerSpeed;
    PVector position, velocity;
    
    Player(float x, float y, float playerRadius) {
        this.position = new PVector(x, y);
        this.velocity = new PVector(0, 0);
        this.playerRadius = playerRadius;
        this.playerSpeed = playerRadius * 0.04f;
    }
    
    public void drawPlayer() {
        updatePlayer();                                               // update player state
        ellipseMode(CENTER);      
        fill(LIGHT_PURPLE);
        noStroke();
        ellipse(position.x, position.y, playerRadius, playerRadius);  // draw player body
    }
    
    public void updatePlayer() {
        velocity.setMag(0);
        if (keys['a'] || keys['A'])     // move left when allowed
            velocity.x = -playerSpeed;
        if (keys['d'] || keys['D'])    // move right when allowed
            velocity.x = playerSpeed;
        if (keys['w'] || keys['W'])      // move up when allowed
            velocity.y = -playerSpeed;
        if (keys['s'] || keys['S'])   // move down when allowed
            velocity.y = playerSpeed;
        integrate();
    }
    
    public void integrate() {
        // if velocity = 0, no need to integrate
        if (velocity.mag() == 0) return;
        // otherwise, update the position
        position.add(velocity);
    }
}


  static public void main(String[] passedArgs) {
    String[] appletArgs = new String[] { "Game" };
    if (passedArgs != null) {
      PApplet.main(concat(appletArgs, passedArgs));
    } else {
      PApplet.main(appletArgs);
    }
  }
}
